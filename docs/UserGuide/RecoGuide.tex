\documentclass{article}

\input{/home/guyn/Dropbox/PhD/TexNotes/Templates/packages}

\renewcommand{\pic}[2][1]{\begin{center}\includegraphics[width=#1\textwidth]{pics/#2} \end{center}}
\renewcommand{\plot}[2][1]{\begin{center}\includegraphics[width=#1\textwidth]{plots/#2} \end{center}}

\newcommand{\class}[1]{\code{#1}}
\newcommand{\module}[1]{\code{#1}}

\usepackage{parskip} 


\begin{document}
 
 \title{Reconstruction framework user guide}
 \author{Guy Nir}
 
 \maketitle
 
 \clearpage
 
 \section{Introduction}

  
 
 \section{Installation}
 
 \clearpage
 
 \section{Quick start}\label{section: quick start}

 This section covers the basic operating modes for the reconstruction framework.
 We encourage new users to open a ROOT session and try to keep up. 
 We will go over some basic examples, and refer the user to more advanced options
 in later sections. 
 
 \subsection{Getting events into the framework}\label{section: basic input data}
 
 To start an analysis session first load the reconstruction library:
 
 \coded{gSystem->Load("\$RECO/libReco.so");}
 
 Where \code{\$RECO} points to the location of the reconstruction folder. 
 If everything is properly installed it should load all the classes needed. 
 It is best to begin the session with:
 
 \coded{Reconstruction reco;}
 
 This generates a \class{StationGeomery} and \class{OpticalIce} objects, 
 and ties the relevant static pointers that need to know about them\footnote{This includes
 \class{Channel}\code{::setGeomety()} and \class{CurvedRay}\code{::setOpticalIce()}.}.
 
 \comment{There are other functions to reco class, but right now they are not working...}
 
 Then there are three input methods:
 
 \begin{itemize}
  \item Built-in simple \class{EventGenerator}. 
  \item Reading files from AraSim using \class{AraSimFileReader}.
  \item Reading data files from AraRoot framework using \class{L0FileReader}.
 \end{itemize}
 
 To generate simple events for the most basic testing 
 (and if you want to run lots of parameters and want to generate millions of events on the fly), 
 start up an object:
 
 \coded{EventGenerator gen;}
 
 The generator is created with default parameters and generates an event on startup. 
 If you want to change some settings look up Section \ref{section: using EventGenerator}. 
 The basic command to include at the start of the loop is:
 
 \coded{gen.generateEvent();}
 
 The generator will happily produce endless events for testing. 
 You can play around with the position range for the vertex, 
 the amplitude of the waveforms (at the source or antennas), 
 the number of antennas receiving signal, and the polarization. 
 
 To get the waveforms into the framework, the basic tool is \class{Channel} objects. 
 Each one holds a waveform, timing data, and the position of the antennas. 
 For more detail see Section \ref{section: using Channel}. Try
 
 \coded{ChannelCollection channels=gen.getChannelCollection();}
 
 This gives you a \class{ChannelCollection} object,
 that is little more than a\linebreak \code{vector<Channel>} object.
 This object holds the full input of the detector or simulation, 
 which is relevant for reconstruction. 

 Another way to get events is to read ROOT files generated by AraSim
 or by AraRoot from real data. The two classes that are required for this
 are \class{AraSimFileReader} and \class{L0FileReader}, that work very similarly. 
 
 \coded{vector<string> filenames; filenames.append("AraOut.root");}
 
 \coded{AraSimFileReader reader(filenames);}
 
 or alternatively 
 
 \coded{L0FileReader reader(filenames);}
 
 Either way it is possible to retrieve the waveforms as before:
 
 \coded{ChannelCollection channels=reader.getChannelCollection();}
 
 It is also useful to get the geometry saved in AraSim or AraRoot
 instead of the default station setup in \class{Reconstruction}:
 
 \coded{reco.setStationGeometry(reader->getStationGeometry());}

 This also assigns the relevant static pointer. 
 To get the next event from file, keep using 
 
 \coded{reader.getNextEvent();}
 
 That returns \code{true} so long as there are new events to process. 
 This function may be placed in a breaking statement, or inside a \code{while} header. 
 
 \subsection{Calculating timing data}\label{section: basic timing data}
 
 Waveforms are primarily used to determine timing data, 
 and the \class{Channel} objects have several functions that calculate it. 
 The user is never exposed to the actual timings, without an implicit call to 
 
 \coded{channels.printout();}
 
 In analyis, the channels are given any command to find the timing results, 
 and the relevant classes are called internally. 
 All results are saved in the channels, that are given as a whole to the next phase of analyis. 
 
 There are three output types for time finding:
 
 \begin{itemize}
  \item Hit times. The point in time each waveform reaches its peak.
  \item Time delays. The difference between each pair in the collection. 
  \item Correlation graphs. The relative strength of the wavefroms multiplied and summed, 
	for different time offsets between each pair of channels. 
 \end{itemize}

 For a system with 16 channels, the hit times will include 16 timing results. 
 For time delays, there are 120 independent pairs of timing results. 
 For correlation graphs, there are 120 graphs, each containing 2048 (interpolated) points, 
 the position of the peak of these graphs is equivalent to the time delays. 
 
 There are several ways to calculate each of these timing results. For example, you could do
 
 \coded{channels.applyFinder(TimeFinder::GAUS);}
 
 Which smooths the waveform and finds its peak. 
 Other methods are discussed further in Section \ref{section: using TimeFinder}. 
 The results of any call to \code{applyFinder} are kept inside the channels and are lazy loaded when called again. 
 
 If you want to produce the time delays from the hit times, 
 a simple class exists that calculates all the pairwise subtractions:
 
 \coded{channels.applyDeltaFinder(DeltaFinder::SUBTRACT);}
  
 Another option is to do the slightly slower 
 
 \coded{channels.applyDeltaFinder(DeltaFinder::CROS);}
 
 That calculates the correlation graphs for each pair. 
 The results of calls to \code{applyDeltaFinder} are also kept in the channels, 
 and are lazy loaded when called again. This method also generates the full graphs, 
 that are kept as \class{CorrGraph} objects for each pair. 
 
 The results that can be used by the following analyis are always those that were
 implemented last. In the examples above, the hit time are still given by the results
 of the call to \class{GausTimeFinder}, while the time delays are given by the results from
 \class{CrosDeltaFinder} rather than the earlier call to \class{SubtractDeltaFinder}. 
 If you want to swap them, just re-apply the previous finders, 
 they are lazy loaded, so once they are called, all subsequent calls are fast. 
 
 \begin{figure}
  
  \centering
  
  \pic[0.9]{CorrGraph}
  
  \caption{Example correlation graph from \class{CorrGraph}, 
	   produced from simulations of \class{EventGenerator}.
	   In this graph the absolute maximum power is at $dt=3.5$\,ns, 
	   which is also the result of the \class{CrosDeltaFinder} object.}
  \label{fig: CorrGraph}
  
 \end{figure}

 
 \subsection{Finding the vertex position}\label{section: basic vertex finding}
 
 Getting vertex localization is the more complicated part. 
 The easiest way to keep track of the different levels of analyis
 is to generate several instances of the subclasses of \class{VertexFinder} 
 and work with them as inputs and outputs. 
 
 First off generate several different types of finders:
 
 \coded{EarliestVertexFinder start\_finder;}
 
 This finder puts the starting position at the position
 of the antenna that was hit first (hence, earliest). 
 Vertex finders look for maximum likelihood for each point in space, 
 and they usually require a good starting position. 
 Some more practical finders can be initialized:
 
 \coded{IntMapVertexFinder intmat\_finder(0,0,0,0,1,36,72);}
 
 or
 
 \coded{MCMCVertexFinder mcmc\_finder(0,0,0,0,1e5,100)}
 
 Where the different parameters specify general settings like 
 coordinate system, hit times or time delay inputs, parameter locks
 or more specific input parameters (see discussion in Section \ref{section: basic vertex finding}).
 
 Once all these finders are initialized, they can be used multiple times
 for different events (or even for the same event with other starting positions). 
 The way to activate them is to call
 
 \coded{start\_finder.findVertex(channels);}
 
 So the first finder looks at the results from the \code{channels} object, 
 and puts the vertex position at the earliest antenna. 
 The next finder on the list can be called based on the results from the first finder
 
 \coded{intmap\_finder.findVertex(channels, start\_finder);}
 
 Along with the starting position, the previous finder also
 gives the new finder some more restrictive error bounds 
 in which to look for the vertex position. 
 You can even call the same finder several times with itself as reference, 
 so that the search narrows down to smaller intervals with better resolution. 
 
 Some finders don't need starting positions, since they scan the whole space anyway. 
 It is still useful to give them another finder, to get updated error bounds and real positions (see below). 
 For example:
 
 \coded{mcmc\_finder.findVertex(channels, intmap\_finder);}
  
 To access the vertex results you can use
 
 \coded{mcmc\_finder.printout();}
 
 All classes in the framework have this method, 
 to make interactive work easier. 
 If you need to pass this information around use, 
 
 \coded{intmap\_finder.getVertexPos();}
 
 Which returns a pointer to a \class{VertexPos} that is a subclass of 
 \class{Pos} class that holds both $x$, $y$, $z$ and $R$, $\theta$, $\phi$. 
 The advanced \class{VertexPos} class also has errors on these sizes, 
 the previous position it was given, and the true position, if known.
 
 If the input source is simulation (either from generator or AraSim), 
 or if the data is known to be cal-pulser events, 
 the true position of the vertex can be given to the first finder in the sequence using
 
 \coded{start\_finder.setRealPosition(gen.getSourcePosition());}
 
 The position is set through a \class{Pos} object, or as $x$, $y$, $z$ coordinates. 
 Once the first finder knowns the true position, it passes it to all other finders 
 when they are linked together. This lets you access the ``residuals'' for each finder result, 
 that are just an easy way to check the distance between the true position and the found position. 
 
 \subsection{Plotting and comparing results}\label{section: basic plotting}
 
 Soon to be updated with the finalization of \class{THX} class. 
 
 \subsection{Saving results}\label{section: basic output}
 
 To write analysis results to root files for further work, 
 we provide the \class{TreeWriter} class. 
 A single object is given the relevat objects, i.e.~the channels and vertex finders:
 
 \coded{TreeWrite writer("filename.root");}
 
 \coded{writer.addChannels(channels);}
 
 Followed by adding any or all finders:
 
 \coded{writer.addFinder(intmap\_finder);}
 
 \coded{writer.addFinder(mcmc\_finder);}
 
 These additions are done within each loop, 
 followed by a command to fill the \class{TTree} with the relevant branches:
 
 \coded{writer.fill();}
 
 Note that by default the writer clears the inputs after filling the tree, 
 unless the user sets \code{writer.setAutoclear(0);} 
 in which case the user must call \code{writer.clearAll();} at the end of each loop. 
 
 Similarly to the commands in ROOT, when the loop is done, a call is made to
 
 \coded{writer.write();} 
 
 to transfer the data from the tree to the open root file. 
 
 
 \subsection{List of time-finders}
 
 Time finders divide into two distinct groups: hit-time finders and delay-finders. 
 Hit times will calculate the absolute timing (relative to the WF's time axis), 
 generally by finding the time of the peak of the WF. 
 Delay finders will provide relative timing between channels, e.g.~the cross correlations. 
 Since reconstruction can be made based on either approach both these ``time inputs'' can be used for vertex finding. 
 
 \begin{itemize}
  \item \class{TimeFinder} is an abstract base class for all hit-time finders.
  \item \class{SimpleTimeFinder} just uses the maximum of the WF. 
  \item \class{ThreshTimeFinder} finds when the WF goes over a threshold as the hit time, 
        and calculates the error based on the number of bins above threshold. 
  \item \class{GausTimeFinder} uses a gaussian smoothing before finding the peak (match filter). 
  \item \class{CSWTimeFinder} uses coherently summed wave to get something like cross-correlation hit times. 
  \item \class{RealTimeFinder} used for simulations when the real hit times are know. 
        Can give true time positions plus random error, for debugging purposes. 
  \item \class{DeltaFinder} inherits from \class{TimeFinder} and is an abstract base class for the pair-wise delay finders.
  \item \class{CrosDeltaFinder} calculates the correlation graphs and finds the peaks to calculate the delays. 
        This is (in most cases) the best method for finding the timing data. 
  \item \class{SubtractDeltaFinder} takes the hit-times and cros-subtracts them to produce delays. 
        Only useful when delays are needed but no real delta-finder has been called. 
 \end{itemize}

 In addition, each pair of \class{Channel} objects can have a \class{CorrGraph} object calculated, 
 which holds the full correlation plot for that pair. This is useful e.g.~for building the interference maps. 
 
 All finders can be called using \code{ChannelCollection::applyFinder} or \linebreak \code{ChannelCollection::applyDeltaFinder}. 
 Each time a finder is called it is lazy loaded (i.e.~only calculate if the result has not been calculated and saved before). 
 This includes the generation of \class{CorrGraph} objects, that are calculated when calling \class{CrosDeltaFinder} or \class{IntMapVertexFinder}.
 So a script can be written that applies a different finder before each step in the vertex-finding process, 
 without needing to recalculate anything. 
 
 \subsection{List of vertex-finders}
 
 The most important thing about vertex finding is to remember to give a starting position 
 to the next vertex finder on the list, e.g.
 
 \coded{finder_b.findVertex(channels, finder_a);}
 
 Some finders do not use a starting position at all, some will benefit from reducing the parameter space 
 (based on the previous finder's confidence intervals), and some will fail miserably without a good starting guess. 
 
 \begin{itemize}
  \item \class{VertexPos} inherits from \class{Pos} and holds the position and also errors for a vertex. 
        All vertex finding results are contained in these objects, and initial positions should be given in this format.
  \item \class{VertexFinder} inherits from \class{VertexPos} and is an abstract base class for all vertex finders. 
        Contains the code for basic operations such as calculating $\chi^2$, deciding on timing parameter and coordinates etc. 
  \item \class{ScanVertexFinder} simply scans over all parameters and calculates the $\chi^2$ for each point. 
        This is the slowest and least accurate method, but also the most reliable. 
        It is useful for sanity checks, for scanning a small region in space or when locking one or two parameters. 
  \item \class{MinuitVertexFinder} uses minimization techniques to find the $\chi^2$ minimum. 
        This method will converge quickly but will need a very good starting guess otherwise it will get stuck at a local minimum.
  \item \class{AnalyticVertexFinder} uses the Analytical Sphere Method that takes four antennas and 
        calculates the solution to the four timing equations. This is very quick but can only use hit times and simple ice models. 
  \item \class{IntMapVertexFinder} generates a few interference maps at different radii and finds the highest correlation value. 
        At high resolution this method is very slow but extremely accurate (in $\th$ and $\phi$ at least). 
  \item \class{MCMCVertexFinder} takes a random walk around the position space based on the Metropolis-Hastings algorithm, 
        giving a 3D map of the probability distribution for the vertex position. 
        This method is very slow, but is very reliable and gives a good view of the degeneracy, local minima and uncertainties
        of the probability distribution for each event. 
  \item \class{EarliestVertexFinder} puts the vertex at the position of the antenna with the earliest hit time. 
        Useful to give as starting position for other finders. Can only get hit-times as inputs. 
  \item \class{AnyWhereVertexFinder} puts the vertex at any location (chosen by the user). Useful for debugging. 
  \item \class{RealVertexFinder} puts the vertex at the real position (simulation or calpulser only), 
        optionally adding errors around that point. Useful for debugging. 
        
 \end{itemize}

 
 \subsection{Vertex finders parameters}
 
 Vertex finders have several parameters that can be defined for each finder, 
 that allow the user to implement very different results based on the same core algorithms. 
 This list includes the basic parameters for most finders, 
 though some finders will happily ignore incompatible parameters (perhaps giving a warning). 
 
 These parameters can be passed via constructor (old method soon to be removed) or via a simple text parser. 
 
 \begin{itemize}
  \item \code{coordinates}: choose \code{CARTESIAN} or 0 to use $x,y,z$. Choose \code{SPHERICAL} or 1 for $R, \th, \phi$. 
  \item \code{times} or \code{inputs}: Choose \code{TIMES} or 0 to reconstruct based on hit-times. 
        Choose \code{PAIRS} or 1 to use pairwise time delays. 
  \item \code{locked} or \code{unlocked}: and specify \code{X} or \code{Y} or \code{Z}, or 0,1,2 respectively 
        to lock or unlock a parameter. In any coordinate choice you can also input \code{R} or \code{THETA} or \code{PHI}. 
  
 \end{itemize}

 This list will updated as more options are added. 
 Also note that each finder will have additional parameters that can be set for their specific needs, 
 e.g.~\class{AnyWhereVertexFinder} will need three coordinates to be supplied by the user. 
 
 \subsection{Vertex finding notes}
 
 changing coordinates and error intervals. locking parameters. initial positions. lazy loading time finders internally. 
 
 \subsection{Vertex finding plotting tools: \class{THX}}
 
 
 
 \clearpage
  
%  \section{Parser commands}
 
 \section{Advanced users}\label{section: advanced users}
 
 note: this section is out-dated and needs serious review.
 
 \subsection{Module Overveiw}\label{section: module overview}
 
%   The reconstruction framework can be accessed directly using calls to methods and classes 
%   that are usually called internally by the parser. 
  Following is a top-down description of the data and command flow, 
  which is based on manager classes (e.g~\class{Reconstruction}), 
  data classes (e.g.~\class{Channel}), worker classes (e.g.~\class{VertexFinder})
  and container classes that unite several data objects (e.g.~\class{EventData}). 
  These distinctions are not absolute. 
  Some of the data classes also do work when required, 
  while some containers also hold information in addition to their contained objects. 
  
  \large\uline{\module{Top level} classes}\normalsize\label{section: module top level}
  
    The top-most level for analysis is \class{Reconstruction} class. 
    This class is given the files to be read, and the output location to write to. 
    The user can supply any objects needed for reconstruction 
    or allow them to be generated by \class{Reconstruction}. 
    Analysis parameters can be given to \class{Reconstruction} either as function calls
    (e.g.~\code{useCartesian()}) or through the \class{Parser} class. 
    
    \class{Reconstruction} is a \emph{persistent} object, that is created once
    and does not need to be changed during an analysis of many events or runs. 
    It contains several other \emph{persistent} classes: 
    
    \begin{itemize}
     \item \class{L0FileReader} or \class{AraSimFileReader} or \class{EventGenerator}
     \item \class{OpticalIce} and \class{StationGeomery}
     \item \class{Output}
%      \item \class{Parser}
    \end{itemize}

    The \class{Reconstruction} object currently only initializes the required objects
    and points the right static pointers to them. Future work will give it more functionality. 
    
%     The \class{Reconstruction} object makes all the calls to the objects needed to do the full analysis. 
%     It requires input and output file names and some setup commands to decide what kind of analysis to do. 
%     After it is set up, it can be told to loop over all events (or a subset) using the same settings. 
    
    \large\uline{\module{InputOutput} module}\normalsize\label{section: module InputOutput}
    
    The input classes, \class{L0FileReader} and \class{AraSimFileReader} are used in a similar manner, 
    they are given a file name (or a list of files) 
    and they parse the root files and extract the needed information 
    as objects within the framework. 
    \class{EventGenerator} can be used instead, to generate simple events without needing any input files. 
    
    The \class{OpticalIce} and \class{StationGeomery} classes are used to contain the environmental data 
    used in the analysis. \class{OpticalIce} determines the ice model used, ice curvature etc. 
    \class{StationGeomery} is a container for \class{AntPos} objects that store the positions 
    and properties of the antennas in the station. 
    
    The \class{Output} class is used to store the location of the output file, 
    and different switches for what portions of the data would be saved to file. 
    It can also output root files as class hierarchy or as simple data members. 
    It can be used to write debugging data and basic reconstruction results as text files. 
    
%     The \class{Parser} class is used to convert user text based commands 
%     to function calls inside the framework. 
%     This can be used in an interactive root session or by inputing an instructions text file. 
%     
    \large\uline{\module{Geometry} module}\normalsize\label{section: module Geometry}
    
    \large\uline{\module{TimeFinding} module}\normalsize\label{section: module TimeFinding}
    
    \large\uline{\module{VertexFinding} module}\normalsize\label{section: module VertexFinding}
    
%     \large\uline{\module{Filtering} module}\normalsize\label{section: Filtering}
  
  \subsection{Simulation basics}\label{section: using basic simulations}
  
    \large{\uline{Using \class{EventGenerator}}\normalsize\label{section: using EventGenerator}
  
    \large\uline{Using \class{StationGeomery}}\normalsize\label{section: using StationGeomery}
    
    \large\uline{Using \class{Pos}}\normalsize\label{section: using Pos}
        
    \large\uline{Using \class{OpticalIce}}\normalsize\label{section: using OpticalIce}
    
    \large\uline{Using \class{CurvedRay}}\normalsize\label{section: using CurvedRay}
    
  \subsection{ROOT files input/output}\label{section: using root files}
   
    \large\uline{Using \class{AraSimFileReader}}\normalsize\label{section: using AraSimFileReader}
    
    \large\uline{Using \class{L0FileReader}}\normalsize\label{section: using L0FileReader}
    
    \large\uline{Using \class{Output}}\normalsize\label{section: using Output}
    
    \large\uline{Using \class{EventData}}\normalsize\label{section: using EventData}
        
  \subsection{Time finding basics}\label{section: using time finding}
  
    \large\uline{Using \class{Channel etc.}}\normalsize\label{section: using Channel}
    
    \large\uline{Using \class{Timing etc.}}\normalsize\label{section: using Timing}
    
    \large\uline{Using \class{TimeFinder} etc.}\normalsize\label{section: using TimeFinder}
    
    \large\uline{Using \class{DeltaFinder} etc.}\normalsize\label{section: using DeltaFinder}
    
    \large\uline{Using \class{CorrGraph}}\normalsize\label{section: using StationGeomery}
    
  \subsection{Vertex finding basics}\label{section: using vertex finding}
  
    \large\uline{Using \class{VertexPos}}\normalsize\label{section: using VertexPos}
    
    \large\uline{Using \class{VertexFinder etc.}}\normalsize\label{section: using VertexFinder}
    
    \large\uline{Using \class{THX}}\normalsize\label{section: using THX}
    
%     \large\uline{Using \class{VertexResult}}\normalsize\label{section: using VertexResult}
    
    
    
%   \subsection{\cl
 
 \section{Class reference}
 
 \section{Improving the framework}
 
  In the following sections we present some coding standards and conventions that should be maintained when adding code to the framework. 
  
  
  \subsection{New \class{TimeFinder} subclasses}
  
  When implementing new subclasses of \class{TimeFinder} 
  it is important to implement a copy constructor that will call the base class' copy constructor:
  
  \coded{SubTimeFinder::SubTimeFinder(const SubTimeFinder &other) : TimeFinder(other) \{...\}}
  
  Make sure to copy in the body any new members added in this class. 
  
  If you have any such new data members, it is important to initialize them 
  in a dedicated call to \code{void initialize()} 
  and also add an implementation of \code{operator=()} that calls \code{TimeFinder::operator=(other)} 
  internally, so that \class{TimeFinder}'s members are all copied over. 
  
  The other critical point is to implement two (otherwise abstract) functions, the first:
    
  code{TimeFinder *SubTimeFinder::getDeepCopy()\{ return new SubTimeFinder(*this); \}}
  
  That calls the copy constructor of the subclass but outputs a pointer to the base class. 
  This allows a copying of polymorphized vectors (such as \code{vector<TimeFinder*>} inside \class{Channel});
  
  The second function is 
  
  \code{virtual void SubTimeFinder::calculateTime()}
 
  That does the actual work, and is called whenever the finder is applied. 
  
  
 
 \section{Committing code}
 
 \section{Benchmarks}
 
 
\end{document}
